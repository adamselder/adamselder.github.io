# Data

## Introduction

### Abstract

The goal of this project is to examine the feasibility of developing an HIV transmission model for use in local HIV prevention planning for heterosexuals.  Advances in HIV treatment and prevention have changed the intervention policy landscape, and public health departments in the US are now tasked with determining which combination of treatment and prevention strategies will have the greatest impact.  Epidemic modeling is a valuable resource for this type of comprehensive HIV prevention planning.  However, these models are often parameterized with a combination of data from multiple populations.  As a result they are not rooted in, or representative of, a local epidemic, even though treatment and prevention strategies are designed mostly at state and local levels in the U.S.   (Source: Abstract from SHAMP/Dropbox/Awarded/RevisedApplication.pdf))


### Terminology

|    Term     |               Definition               |
|:-----------:|:--------------------------------------:|
|     sb      |            (sex-black race)            |
|     ds      |              (degree-sex)              |
|     dsb     |         (degree-sex-black race)        |
|    cohab    |              cohabitating              |
|    pers     |         persistent relationship        |
|     ot      |                 onetime                |
|      H      |                Hispanic                |
|     HI      |           Hispanic Immigrant           |
|     BI      |      Non-Hispanic Black immigrant      |
|     BI      |           Non-Hispanic Black           |
|      W      |           Non-Hispanic Other           |
|      W      |           Non-Hispanic White           |
|    xnet     |              cross-network             |
|    conc     |               Concurrency              |
| components  | disconnected parts of a social network |
|    S/C      |             Spouse or cohab            |
| dissolution |          relationship dissolving       |
|    offset   |ERGM term: no relationships of any type |
|    netdx    | EpiModel term to make ERGM diagnostics |
|static netdx |      no dissolution included           |
|dynamic netdx|    allow relationship dissolution      |

### Previous presentations 

Nov 9, 2016 - [Roxanne Kerani, African Immigrants Living with HIV in King County, WA](../../../docs/SHAMP_Presentations/Kerani_SHAMP_2016_1109.pdf)

July 7, 2018 - [Deven Hamilton, Partnerships durations: Do they meet our expectations?](../../../docs/SHAMP_Presentations/NMG_7_17_2018_durations.pdf)

Sep 20, 2018 - [Martina Morris, Syphillis Eradication Summit, California Department of Public Health](../../../docs/SHAMP_Presentations/CPDH%20Bridging%20Networks.pdf)

October 2018 - [Martina Morris, EpiMed Discussion](../../../docs/SHAMP_Presentations/EpiMed530 2018)

May 6, 2019 - [PHSKC/SPRC Lunchbox Talk](../../../docs/SHAMP_Presentations/LunchboxFinal.pdf)


### Review of local behavioral surveys


<!-- ![from Darcy Rao, https://github.com/statnet/SHAMP/issues/2#issuecomment-264993247](../../../docs/figs/Issue_2_compare.PNG) -->

<!-- ![List of SHAMP datasets, https://github.com/statnet/SHAMP/issues/2#issuecomment-264558058](../../../docs/figs/snglick_SHAMP_datasets.PNG) -->


### Public Health Seattle King County (PHSKC) Washington Department of Health (WADOH) Surveillance

Briefly considered merging data about the population into a merged population (pseudopop), but decided not to. See Issue [#46](https://github.com/statnet/SHAMP/issues/46). Additional information about creating pseudopop estimates from PHSKC are detailed in [Issue #37](https://github.com/statnet/SHAMP/issues/37).

See more information from Susan Buskin at [Issue #36](https://github.com/statnet/SHAMP/issues/36). Table shells, and more information about the PHSKC, are in [Issue #23](https://github.com/statnet/SHAMP/issues/23).

For MMP data: we did not use it, but see ]Issue #19](https://github.com/statnet/SHAMP/issues/19) on more information about it.

### National Population based surveys used in final model

_NSFG - National Survey of Family Growth - CDC._ *used in final models*

Longitudinal study done in cycles by the CDC to measure trends related to families, fertiliy and health (Source: [CDC](https://www.cdc.gov/nchs/nsfg.htm)).**

**Information to note for future SHAMP-related projects:** The 2006-2010 datasets had data on contacts for sexual data. This needed a request through CSDE to obtain. 2015-2017 did not include those variables. 

- __Age group available:__ 15-45 [Issue #9](https://github.com/statnet/SHAMP/issues/9)
- __Coital acts:__ Not Available [Issue #10](https://github.com/statnet/SHAMP/issues/10)
- __Condom use:__ Available [Issue #11](https://github.com/statnet/SHAMP/issues/11)


_NHANES - National Health and Nutrition Examination Survey_ *used for weighting parameters*

>The National Health and Nutrition Examination Survey (NHANES) is a program of studies designed to assess the health and nutritional status of adults and children in the United States. (Source: [NHANES, CDC](https://www.google.com/search?client=firefox-b-1-d&q=nhanes))


### Other data sources explored for the project, did not use in final models

_NHSLS - National Health and Social Life Survey - ICPSR._

 This was a cross-sectional interview of 3,432 total cases on various social life indicators, such as income, AIDs vulnerability, marital and cohab, fertility, and sexual activity. (Source: [ICPSR, UMich](https://www.icpsr.umich.edu/icpsrweb/HMCA/studies/6647/variables))

- __Age group available:__ 18-59 [Issue #9](https://github.com/statnet/SHAMP/issues/9)
- __Coital acts:__ Available [Issue #10](https://github.com/statnet/SHAMP/issues/10)
- __Condom use:__ Available [Issue #11](https://github.com/statnet/SHAMP/issues/11)

*NHBS*

![ ](https://www.cdc.gov/hiv/images/statistics/systems/nhbs/nhbs-logo2.png)

CDC longitudinal survey done in cycles to conduct behavioral surveillance among persons at high risk for HIV infection. (https://www.cdc.gov/hiv/statistics/systems/nhbs/index.html)

- __Age group available:__ 18-50+ 
- __Coital acts:__  Available 
- __Condom use:__ Available 

According to [Issue #49](https://github.com/statnet/SHAMP/issues/49): "From NHBS, they report ITI for MSM in 2013 is 7.7 mos and for high-risk heterosexuals is 19.9 mos."

_Add Health - National Longitudinal Study of Adolescent to Adult Health_

The National Longitudinal Study of Adolescent to Adult Health (Add Health) is a longitudinal study of a nationally representative sample of adolescents in grades 7-12 in the United States during the 1994-95 school year. The Add Health cohort has been followed into young adulthood with four in-home interviews, the most recent in 2008, when the sample was aged 24-3. (Source: [CSDE Data Repository](https://dcollab.uw.edu/data/add-health/))


## Local survey estimates {#targets}

As referenced in Issues [#135](https://github.com/statnet/SHAMP/issues/135) and [#48](https://github.com/statnet/SHAMP/issues/48), 
  we have calculated the target prevalence statistics as below:
    ![Found in FinalTargets.xlsx*](https://user-images.githubusercontent.com/8194530/57264773-b50c5d80-7028-11e9-8187-14e18444ad9a.png) 
    
    
    
### The rationale for simulating large population sizes

The population size of Seattle proper in King County is estimated to be 729,601, as of 2017 ( https://www.census.gov/programs-surveys/popest/data/tables.2018.html). The annual adjusted HIV incidence and prevalence for non-MSM population in KC from 2013-2017 are listed below. The adjusted annual HIV incidence per 100,000 people is 5.14 , and the adjusted annual prevalence per 100,000 people is 84.77. With these numbers, we calculated examples of numbers for incidence and prevalence in test populations of 50,000 to 800,000.

| Population Size | Incidence Calculation  | Prevalence Calculation  | Incidence | Prevalence |
|-----------------|------------------------|-------------------------|-----------|------------|
| 50,000          | 50,000 * 5.14/100,000  | 50,000 * 84.77/100,000  | 3         | 42         |
| 100,000         | 100,000 * 5.14/100,000 | 100,000 * 84.77/100,000 | 5         | 85         |
| 200,000         | 200,000 * 5.14/100,000 | 200,000 * 84.77/100,000 | 10        | 170        |
| 300,000         | 300,000 * 5.14/100,000 | 300,000 * 84.77/100,000 | 15        | 254        |
| 400,000         | 400,000 * 5.14/100,000 | 400,000 * 84.77/100,000 | 21        | 339        |
| 500,000         | 500,000 * 5.14/100,000 | 500,000 * 84.77/100,000 | 26        | 424        |
| 600,000         | 600,000 * 5.14/100,000 | 600,000 * 84.77/100,000 | 31        | 509        |
| 700,000         | 700,000 * 5.14/100,000 | 700,000 * 84.77/100,000 | 36        | 593        |
| **800,000**         | **800,000 * 5.14/100,000** | **800,000 * 84.77/100,000** | **41**        | **678**        |

We've picked our target incidence/prevalence to be 800,000, as the incidence number is more robust than other population sizes. See Issue [#148](https://github.com/statnet/SHAMP/issues/148).


* For the data: ask Sara or Jeanette for the HIV prevalence/incidence data (stored under `Dropbox/SHAMP/Data/PrevInciTargets`, under the TargetsHi, TargetsLow, and FinalTargets workbooks).


## Descriptive Characteristics

### Ego Characteristics

```{r egos-setup, include=F,code=readLines('code/setup/packages-options.R')}
detach("package:srvyr", unload=TRUE)
library(srvyr)
```

```{r, echo=FALSE, include=FALSE}
# https://github.com/rstudio/DT/issues/67
# You need this code to conduct the magic dependences attaching...
# Without it, the loops with DTs in them did NOT print
DT::datatable(matrix())
```

```{r egos-mutate, echo=FALSE}
#--------------------------------------------------------------------------------
# Survey object for ego tibble
#--------------------------------------------------------------------------------
#egos <- network_list[[1]]$egos 
egos <- as_tibble(egos) %>%
    mutate(any_pers=deg.pers>0,
           any_cohab=deg.cohab>0)

svy <- egos %>% as_survey(ids=1, weights=weight)


```

```{r egos-tabs-plots-1way}
#------------------------------------------------------------
# 1-way stats: 
# compute tabs and generate plots
#------------------------------------------------------------

# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop
tables_1way <- list()
DTables_1way <- htmltools::tagList()
plots_1way <- htmltools::tagList()
for (i in 1:length(ego_1way_vars)) {
    var <- ego_1way_vars[i]
    tables_1way[[i]] <- prop_kvar(svy, var, char_input=TRUE, binary=FALSE)
    DTables_1way[[i]] <- DT::datatable(tables_1way[[i]],
					   height="100%",
					   width="100%", rownames=FALSE)
#    plots_1way[[i]] <- as_widget(ggplotly(plot_1var(tables_1way[[i]], var, char_input=TRUE)))
    plots_1way[[i]] <- as_widget(plotly::style(plot_1var(tables_1way[[i]], var, char_input=TRUE),
					       hoverinfo='y'))
}
names(tables_1way) <- names(DTables_1way) <- names(plots_1way) <- ego_1way_vars
``` 

```{r egos-tabs-plots-1way_cont}
#------------------------------------------------------------
# 1-way stats, CONTINUOUS:
# compute tabs and generate plots
#------------------------------------------------------------
 detach("package:srvyr", unload=TRUE)
library(srvyr)

# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop
tables_1way_cont <- list()
DTables_1way_cont <- htmltools::tagList()
plots_1way_cont <- htmltools::tagList()
plots_1way_cont2 <- htmltools::tagList()
for (i in 1:length(ego_1way_vars_continuous)) {
    var <- ego_1way_vars_continuous[i]
    tables_1way_cont[[i]] <- tab_continuous(svy, var, char_input=TRUE)
    DTables_1way_cont[[i]] <- DT::datatable(tables_1way_cont[[i]],
					   height="100%",
					   width="100%", rownames=FALSE)
    plots_1way_cont[[i]] <- 
	as_widget(ggplotly(plot_1var_continuous(egos, var, char_input=TRUE, type='histogram')))
    plots_1way_cont2[[i]] <- as_widget(ggplotly(plot_1var_continuous(egos, var, char_input=TRUE)))
}
names(tables_1way_cont) <- names(DTables_1way_cont) <- names(plots_1way_cont) <- names(plots_1way_cont2) <- ego_1way_vars_continuous
``` 

```{r egos-tabs-plots-2way}
#------------------------------------------------------------
# 2-way stats: 
# compute tabs and generate plots
#------------------------------------------------------------

# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop
tables_2way <- list()
DTables_2way <- htmltools::tagList()
plots_2way <- htmltools::tagList()
for (i in 1:length(ego_2way_vars)) {
    var <- ego_2way_vars[[i]][1]
    group_var <- ego_2way_vars[[i]][2]
    tables_2way[[i]] <- prop_kvar(svy, var, 
			     char_input=TRUE, binary=FALSE, group_var)
    DTables_2way[[i]] <- DT::datatable(tables_2way[[i]],
					   height="100%",
					   width="100%", rownames=FALSE)
#    plots_2way[[i]] <- as_widget(ggplotly(plot_kvar(tables_2way[[i]], var, group_var, char_input=TRUE)))
    plots_2way[[i]] <- as_widget(plotly::style(plot_kvar(tables_2way[[i]], var, group_var, char_input=TRUE),
					       hoverinfo='y'))
}
# Create collapsed vector for names
ego_2way_vars_names <- sapply(ego_2way_vars, paste, collapse='_by_')
names(tables_2way) <- names(DTables_2way) <- names(plots_2way) <- ego_2way_vars_names
``` 

```{r egos-tabs-plots-2way-continuous}
#------------------------------------------------------------
# 2-way stats CONTINUOUS: 
# compute tabs and generate plots
#------------------------------------------------------------

# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop
tables_2way_cont <- list()
DTables_2way_cont <- htmltools::tagList()
plots_2way_cont <- htmltools::tagList()
plots_2way_cont2 <- htmltools::tagList()
for (i in 1:length(ego_2way_vars_continuous)) {
    var <- ego_2way_vars_continuous[[i]][1]
    group_var <- ego_2way_vars_continuous[[i]][2]
    tab <- tab_continuous(svy, var, char_input=TRUE, round_to=1, group_var)
    tab <- tab %>% select(1, length(tab), everything()) %>% arrange_at(vars(group_var, 'stat'))
    tables_2way_cont[[i]] <- tab
    DTables_2way_cont[[i]] <- DT::datatable(tables_2way_cont[[i]],
					   height="100%",
					   width="100%", rownames=FALSE)
    # Density
    plots_2way_cont[[i]] <- as_widget(ggplotly(plot_kvar_continuous(egos, var, group_var, char_input=TRUE)))
    # Boxplot
    plots_2way_cont2[[i]] <- as_widget(ggplotly(plot_kvar_continuous(egos, var, group_var, char_input=TRUE, type='boxplot')))
    # Couldn't get this to work, but since the table has the CI's, I don't think it's a problem that I used ggplot with weights 
    # given the survey design is approximated as 1-stage with post-stratification weights
    # plots_2way_cont2[[i]] <- survey::svyboxplot(eval(parse(text=var)) ~ eval(parse(text=group_var)), svy, all.outliers=TRUE)
}
# Create collapsed vector for names
ego_2way_vars_continuous_names <- sapply(ego_2way_vars_continuous, paste, collapse='_by_')
names(tables_2way_cont) <- names(DTables_2way_cont) <- names(plots_2way_cont) <- names(plots_2way_cont2) <- ego_2way_vars_continuous_names
``` 

#### One-way margins

The following plots show the percent composition of the variable values within the entire sample. Percents sum to 100% over the x-axis values.

```{r ego-1way-stats, results='asis'}
#------------------------------------------------------------
# 1-way stats: 
# print
#------------------------------------------------------------

for (var in ego_1way_vars){
   cat('\n')  

   # Establish section header and an ID for it, for cross-referencing
   cat("#### ", var, " {#egos-1way-", var, "}", "\n", sep="") 

    # Plotly
    x <- plots_1way[[var]]
    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x)$html)
    }

    # Print DT
    cat(knitr::knit_print(DTables_1way[[var]]))

   cat('\n') 
}
```

```{r egos-plotly-stuff-1way, echo=FALSE, messages=FALSE, warning=FALSE}
#------------------------------------------------------------
# Stuff necessary for plotly plots to print in a loop
# https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
# 
# KEY TO REALIZE: to have more than one loop of plotly graphs print at 
# different points in the same Rmd file, the "deps_1way" variable must
# have a unique name for each loop. So here, we have 1way, and later down,
# this code repeats again after the 2way loop with "deps_2way"
#------------------------------------------------------------
    # attach the Dependencies
    # since the do not get included with renderTags(...)$html
    deps_1way <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_1way),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_1way,recursive=FALSE)
    )
```

```{r ego-1way-stats-continuous, results='asis'}
#------------------------------------------------------------
# 1-way stats continuous: 
# print
#------------------------------------------------------------

for (var in ego_1way_vars_continuous){
   cat('\n')  

   # Establish section header and an ID for it, for cross-referencing
   cat("#### ", var, " {#egos-1way-cont", var, "}", "\n", sep="") 

    # Plotly
    x <- plots_1way_cont[[var]]
    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x)$html)
    }
    x2 <- plots_1way_cont2[[var]]
    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x2,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x2,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x2)$html)
    }

    # Print DT
    cat(knitr::knit_print(DTables_1way_cont[[var]]))

   cat('\n') 
}
```

```{r egos-plotly-stuff-1way-continuous, echo=FALSE, messages=FALSE, warning=FALSE}
#------------------------------------------------------------
# Stuff necessary for plotly plots to print in a loop
# https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
# 
# KEY TO REALIZE: to have more than one loop of plotly graphs print at 
# different points in the same Rmd file, the "deps_1way" variable must
# have a unique name for each loop. So here, we have 1way, and later down,
# this code repeats again after the 2way loop with "deps_2way"
#------------------------------------------------------------
    # attach the Dependencies
    # since the do not get included with renderTags(...)$html
    deps_1way_cont <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_1way_cont),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_1way_cont,recursive=FALSE)
    )

    deps_1way_cont2 <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_1way_cont2),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_1way_cont2,recursive=FALSE)
    )
```

#### Cross-tabs

The following plots show the percent composition of the first variable WITHIN groups defined by the second variable. Percents sum to 100% within x-axis groups (i.e., the sum of immediately adjacent, uniquely colored bars is 100%).


```{r ego-2way-stats, results='asis'}
#------------------------------------------------------------
# 2-way stats: 
# print
#------------------------------------------------------------

for (var in ego_2way_vars_names){
   cat('\n')  
   cat("#### ", var, " {#egos-2way-", var, "}", "\n", sep="") 

   # Now print the plot_ly
    x <- plots_2way[[var]]
    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x)$html)
    }

    # Print DT
    cat(knitr::knit_print(DTables_2way[[var]]))

   cat('\n') 
}
```

```{r egos-plotly-stuff-2way, echo=FALSE, messages=FALSE, warning=FALSE}
#------------------------------------------------------------
# Stuff necessary for plotly plots to print in a loop
# https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
#------------------------------------------------------------
    # attach the Dependencies
    # since the do not get included with renderTags(...)$html
    deps_2way <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_2way),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_2way,recursive=FALSE)
    )
```

```{r ego-2way-stats-continuous, results='asis'}
#------------------------------------------------------------
# 2-way stats CONTINUOUS: 
# print
#------------------------------------------------------------

for (var in ego_2way_vars_continuous_names){
   cat('\n')  
   cat("#### ", var, " {#egos-2way-cont-", var, "}", "\n", sep="") 

   # Now print the plot_ly
    x <- plots_2way_cont[[var]]
    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x)$html)
    }
    x2 <- plots_2way_cont2[[var]]
    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x2,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x2,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x2)$html)
    }

    # Print DT
    cat(knitr::knit_print(DTables_2way_cont[[var]]))

   cat('\n') 
}
```

```{r egos-plotly-stuff-2way-continuous, echo=FALSE, messages=FALSE, warning=FALSE}
#------------------------------------------------------------
# Stuff necessary for plotly plots to print in a loop
# https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
#------------------------------------------------------------
    # attach the Dependencies
    # since the do not get included with renderTags(...)$html
    deps_2way_cont <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_2way_cont),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_2way_cont,recursive=FALSE)
    )

    deps_2way_cont2 <- lapply(
      Filter(function(x2){inherits(x2,"htmlwidget")},plots_2way_cont2),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_2way_cont2,recursive=FALSE)
    )
```


### Network Characteristics

#### Degree

```{r, echo=FALSE, include=FALSE}
# https://github.com/rstudio/DT/issues/67
# You need this code to conduct the magic dependences attaching...
# Without it, the loops with DTs in them did NOT print
DT::datatable(matrix())
```


```{r degree-mutate}
#--------------------------------------------------------------------------------
# Ego tibble
#--------------------------------------------------------------------------------
egos <- network_list[[1]]$egos 
egos <- as_tibble(egos)

#--------------------------------------------------------------------------------
# Make some additional degree variables based on the ones provided - 
# this may not be necessary
#--------------------------------------------------------------------------------

# Variable that stores the joint degree values for each network pair
# It will be a concatenation of the degree vars, e.g. "deg.cohab-deg.pers"

# Also create concurrency indicators for within-net conc for each net
# and cross-net conc. They will be, e.g.
#     Cross-net conc: "deg.cohab-deg.pers_crossconc"
#     Within-net conc: "deg.cohab_conc"
#     Any conc: "deg.cohab-deg.pers_anyconc"

names(network_pairs) <- sapply(network_pairs, paste, collapse='-')
for (i in 1:length(network_pairs)) {
    
    # Convert to names that can be unquoted
    joint_name <- rlang::sym(names(network_pairs)[i])
    net1 <- rlang::sym(network_pairs[[i]][1])
    net2 <- rlang::sym(network_pairs[[i]][2])
    pair <- rlang::syms(network_pairs[[i]])
    # Create names for new variables
    cross_conc <- paste0(quo_name(joint_name), '_crossconc_only')
    any_conc <- paste0(quo_name(joint_name), '_anyconc')
    net1_conc <- paste0(quo_name(net1), '_conc_only')
    net1_cross_conc <- paste0(quo_name(net1), '_and_cross_conc')
    net2_cross_conc <- paste0(quo_name(net2), '_and_cross_conc')
    net2_conc <- paste0(quo_name(net2), '_conc_only')

    # Create     
    egos <- egos %>% 
	# Joint degree variable
	unite(!!joint_name, !!!pair, remove=FALSE)  %>% 
	# Concurrency indicators. I believe they must be 1/0 not TRUE/FALSE for survey pkg
	mutate(!!cross_conc := ifelse(!!net1 == 1 & !!net2 == 1, 1, 0),
	       !!net1_conc := ifelse(!!net1 > 1 & !!net2==0, 1, 0),
	       !!net2_conc := ifelse(!!net2 > 1 & !!net1==0, 1, 0),
	       !!net1_cross_conc := ifelse(!!net1 > 1 & !!net2 > 0, 1, 0),
	       !!net2_cross_conc := ifelse(!!net2 > 1 & !!net1 > 0, 1, 0),
	       !!any_conc := ifelse(!!net1 > 1 | !!net2 > 1 | (!!net1 > 0 & !!net2 > 0), 1, 0)
	       )

    if (1==0) {
	egos %>% table('deg.pers_conc', 'deg.cohab_conc')
	egos %>% group_by(`deg.cohab-deg.pers_anyconc`, `deg.cohab-deg.pers_crossconc_only`, 
			  deg.cohab_and_cross_conc, 
			  deg.pers_and_cross_conc, 
			  deg.pers_conc_only, deg.cohab_conc_only) %>% summarize(count=n())
    }

}

#--------------------------------------------------------------------------------
# Survey object for ego tibble
#--------------------------------------------------------------------------------
svy <- egos %>% as_survey(ids=1, weights=weight)

```
```{r, echo=FALSE,include = FALSE}
# CHECKING OUT DATA TABLE
# https://github.com/rstudio/DT/issues/67
# You need this code to conduct the magic dependences attaching...
DT::datatable(matrix())
```

```{r degree-tabs-plots-nets-overview}
#------------------------------------------------------------
# Mean degree and degree distributions:
# compute tabs and generate plots
#------------------------------------------------------------

# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop

tables_nets_overview <- list()
plots_nets_overview <- htmltools::tagList()

for (i in 1:length(degree_vars)) {
    var <- degree_vars[i]
    tables_nets_overview[[i]] <- 
	transform(Network=names(degree_vars)[i],
		  mean_deg_kvar(svy, var, char_input=TRUE, round_to=3))
}

sumtable_nets_overview <- do.call('rbind', tables_nets_overview)
# For use with datatable
sumtable_nets_overview_DT <- DT::datatable(sumtable_nets_overview, 
					   height="100%",
					   width="100%", 
					   rownames=FALSE)
plots_nets_overview <- plotly::style(plot_1var_mean_degree(sumtable_nets_overview, 
						       Network, char_input=FALSE),
				     hoverinfo='y')
``` 

```{r degree-tabs-plots-1way}
#------------------------------------------------------------
# 1-way stats: 
# compute tabs and generate plots
#------------------------------------------------------------

tables_1way_mean <- list()
DTables_1way_mean <- htmltools::tagList()
plots_1way_mean <- htmltools::tagList()
# Not using this right now
tables_1way_distr <- list()
# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop
plots_1way_distr <- htmltools::tagList()

for (i in 1:length(degree_1way_vars)) {
    var <- degree_1way_vars[i]

    tables_1way_mean[[i]] <- combine_mean_deg_nets(svy, degree_vars, 
						   char_input=TRUE, var)
    # Plot input must be a data frame, not a DT object. So turn it into DT separately.
    DTables_1way_mean[[i]] <- DT::datatable(tables_1way_mean[[i]],
					   height="100%",
					   width="100%", rownames=FALSE)
    plots_1way_mean[[i]] <- 
	as_widget(plotly::style(plot_kvar_mean_degree(tables_1way_mean[[i]], var, 
						      'network', 
						      char_input=TRUE), 
				hoverinfo='y'))
}
names(tables_1way_mean) <- names(DTables_1way_mean) <- 
    names(plots_1way_mean) <- degree_1way_vars
``` 

```{r degree-tabs-plots-2way}
#------------------------------------------------------------
# 2-way stats: 
# compute tabs and generate plots
#------------------------------------------------------------

# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop
tables_2way_mean <- list()
DTables_2way_mean <- htmltools::tagList()
plots_2way_mean <- htmltools::tagList()
tables_2way_distr <- list()
plots_2way_distr <- htmltools::tagList()

for (i in 1:length(degree_2way_vars)) {
    tables_2way_mean[[i]] <- combine_mean_deg_nets(svy, degree_vars, char_input=TRUE, 
						   degree_2way_vars[[i]])
    # Plot input must be a data frame, not a DT object. So turn it into DT separately.
    DTables_2way_mean[[i]] <- DT::datatable(tables_2way_mean[[i]],
					   height="100%",
					   width="100%", rownames=FALSE)
    plots_2way_mean[[i]] <- 
	as_widget(plotly::style(plot_kvar_mean_degree(tables_2way_mean[[i]], 
						      degree_2way_vars[[i]][1],
						      degree_2way_vars[[i]][2],
						      char_input=TRUE,
						      'network'),
				hoverinfo='y'))
}
degree_2way_vars_names <- sapply(degree_2way_vars, paste, collapse='_by_')
names(tables_2way_mean) <- names(DTables_2way_mean) <- 
    names(plots_2way_mean) <- degree_2way_vars_names
``` 

```{r degree-tabs-plots-crossnet-overview}
#------------------------------------------------------------
# Cross-network degree distribution for all network pairs
#------------------------------------------------------------

# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop
tables_crossnet_overview <- list()
DTables_crossnet_overview <- htmltools::tagList()
plots_crossnet_overview <- htmltools::tagList()
plots_crossnet_overview2 <- htmltools::tagList()

for (i in 1:length(network_pairs)) {

    # Convert to names that can be unquoted
    joint_name <- rlang::sym(names(network_pairs)[i])
    pair <- rlang::syms(network_pairs[[i]])
    pair1 <- rlang::sym(network_pairs[[i]][1])
    pair2 <- rlang::sym(network_pairs[[i]][2])

    # This is scarily slow
    tables_crossnet_overview[[i]] <- prop_kvar(svy, joint_name, 
					       char_input=TRUE, binary=FALSE)%>% 
				     separate(!!joint_name, into=c(network_pairs[[i]][1], 
								   network_pairs[[i]][2]))  %>% 
				     mutate(value=prop,
					    concurrency = ifelse(!!pair1 > 1 | !!pair2 > 1 | (!!pair1 > 0 & !!pair2 > 0), 'Concurrency', 'No conc'))

    # Plot input must be a data frame, not a DT object. So turn it into DT separately.
    DTables_crossnet_overview[[i]] <- DT::datatable(tables_crossnet_overview[[i]],
					   height="100%",
					   width="100%", rownames=FALSE)
    plots_crossnet_overview[[i]] <- 
	as_widget(plotly::style(
				plot_kvar(tables_crossnet_overview[[i]], 
					  network_pairs[[i]][1],
					  network_pairs[[i]][2],
					  char_input=TRUE) + 
				ggtitle(paste('Joint distribution of',
					    paste(network_pairs[[i]], collapse=', ')
					)),
				hoverinfo='y'))

    # Second plot with no error bars
    plot2 <- 
	ggplot(tables_crossnet_overview[[i]],
		   aes(x=deg.pers, y=deg.cohab, size=prop, color=concurrency)) + 
		    geom_point() +
		    scale_size_continuous(range=c(0,20)) +
#			scale_fill_manual(values=c('springgreen4', 'gray68')) +
		    scale_color_manual(values=c('springgreen4', 'gray68')) +
		    theme_bw() + 
		    guides(size=FALSE) + 
		    labs(color='') + 
#		    facet_grid(network~.) +
		    ggtitle('Joint distribution, no error bars')

    # I don't know why this works but plotly::style with hoverinfo='prop' does not
    plots_crossnet_overview2[[i]] <- as_widget(plotly::ggplotly(plot2, tooltip='prop',
						  height=300, 
						  width=600))
}
names(tables_crossnet_overview) <- names(DTables_crossnet_overview) <- 
    names(plots_crossnet_overview) <- names(plots_crossnet_overview2) <- names(network_pairs)
``` 

```{r degree-tabs-plots-concurrency-1way}
#------------------------------------------------------------
# 1-way concurrency and crossnet tab for all network pairs
#------------------------------------------------------------

# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop
tables_conc_1way <- list()
DTables_conc_1way <- list()
tables_crossnet_1way <- list()
DTables_crossnet_1way <- list()
plots_conc_1way <- list()
plots_crossnet_1way <- list()

for (i in 1:length(network_pairs)) {
    
    # Define sub-lists for this network pair
    tables_conc_1way[[i]] <- list()
    DTables_conc_1way[[i]] <- htmltools::tagList()
    tables_crossnet_1way[[i]] <- list()
    DTables_crossnet_1way[[i]] <- htmltools::tagList()
    plots_conc_1way[[i]] <- htmltools::tagList()
    plots_crossnet_1way[[i]] <- htmltools::tagList()


    # Identify concurrency variables for this network vair

    # Convert to names that can be unquoted
    joint_name <- rlang::sym(names(network_pairs)[i])
    net1 <- rlang::sym(network_pairs[[i]][1])
    net2 <- rlang::sym(network_pairs[[i]][2])
    pair <- rlang::syms(network_pairs[[i]])
    # Conc variables names
    cross_conc <- paste0(quo_name(joint_name), '_crossconc_only')
    any_conc <- paste0(quo_name(joint_name), '_anyconc')
    net1_conc <- paste0(quo_name(net1), '_conc_only')
    net1_cross_conc <- paste0(quo_name(net1), '_and_cross_conc')
    net2_cross_conc <- paste0(quo_name(net2), '_and_cross_conc')
    net2_conc <- paste0(quo_name(net2), '_conc_only')
    # Conc variables
    net1_conc_var <- rlang::sym(net1_conc)
    net2_conc_var <- rlang::sym(net2_conc)
    net1_cross_conc_var <- rlang::sym(net1_cross_conc)
    net2_cross_conc_var <- rlang::sym(net2_cross_conc)
    cross_conc_var <- rlang::sym(cross_conc)
    any_conc_var <- rlang::sym(any_conc)

    # Now do 1-way stats by variables

    for (j in 1:length(degree_1way_vars)) {

	var <- rlang::sym(degree_1way_vars[j])

	#Cross-network tab
	tables_crossnet_1way[[i]][[j]] <- prop_kvar(svy, joint_name, 
						   char_input=TRUE, binary=FALSE, degree_1way_vars[j]) %>% 
					 separate(!!joint_name, into=c(network_pairs[[i]][1], 
								       network_pairs[[i]][2]))  %>% 
					 mutate(value=prop,
						concurrency = ifelse(!!pair1 > 1 | !!pair2 > 1 | (!!pair1 > 0 & !!pair2 > 0), 
								     'Concurrency', 'No conc'))

	# Plot input must be a data frame, not a DT object. So turn it into DT separately.
	DTables_crossnet_1way[[i]][[j]] <- DT::datatable(tables_crossnet_1way[[i]][[j]],
					       height="100%",
					       width="100%", rownames=FALSE)
	plots_crossnet_1way[[i]][[j]] <- 
	    ggplot(tables_crossnet_1way[[i]][[j]],
		       aes(x=deg.pers, y=deg.cohab, size=prop, color=concurrency)) + 
			geom_point() +
			scale_size_continuous(range=c(0,20)) +
    #			scale_fill_manual(values=c('springgreen4', 'gray68')) +
			scale_color_manual(values=c('springgreen4', 'gray68')) +
			theme_bw() + 
			guides(size=FALSE) + 
			labs(color='') + 
			facet_wrap(vars(!!var)) +
			ggtitle(paste('Joint distribution within', degree_1way_vars[j]))

	# I don't know why this works but plotly::style with hoverinfo='prop' does not
	plots_crossnet_1way[[i]][[j]] <- 
	    as_widget(plotly::ggplotly(plots_crossnet_1way[[i]][[j]], tooltip='prop',
						      height=400, 
						      width=800))

	# Concurrency
	tables_conc_1way[[i]][[j]] <- 
	    bind_rows(
		prop_kvar(svy, !!net1_conc_var, binary=TRUE, char_input=FALSE, !!var) %>% 
		    mutate(conc_measure = paste(quo_name(net1), 'only')),

		prop_kvar(svy, !!net2_conc_var, binary=TRUE, char_input=FALSE, !!var) %>% 
		    mutate(conc_measure = paste(quo_name(net2), 'only')),

		prop_kvar(svy, !!cross_conc_var, binary=TRUE, char_input=FALSE, !!var) %>% 
		    mutate(conc_measure = 'cross only'),

		prop_kvar(svy, !!net1_cross_conc_var, binary=TRUE, char_input=FALSE, !!var) %>% 
		    mutate(conc_measure = paste(quo_name(net1), 'and cross')) ,

		prop_kvar(svy, !!net2_cross_conc_var, binary=TRUE, char_input=FALSE, !!var) %>% 
		    mutate(conc_measure = paste(quo_name(net2), 'and cross')),

		prop_kvar(svy, !!any_conc_var, binary=TRUE, char_input=FALSE, !!var) %>% 
		    mutate(conc_measure = 'any')

		)
	
	    
	# Plot input must be a data frame, not a DT object. So turn it into DT separately.
	DTables_conc_1way[[i]][[j]] <- DT::datatable(tables_conc_1way[[i]][[j]],
					       height="100%",
					       width="100%", rownames=FALSE)

	# Rotate x labels because they're a little long
	thisplot <- plot_kvar(tables_conc_1way[[i]][[j]], !!var, 
			      conc_measure, char_input=FALSE) + 
		    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
		    ggtitle(paste('Percent of', degree_1way_vars[j], 'with concurrency measure'))

	plots_conc_1way[[i]][[j]] <- 
	    as_widget(plotly::style(thisplot, hoverinfo='y'))

    }
    names(tables_conc_1way[[i]]) <- names(DTables_conc_1way[[i]]) <- 
	names(plots_conc_1way[[i]]) <- 
    names(tables_crossnet_1way[[i]]) <- names(DTables_crossnet_1way[[i]]) <- 
	names(plots_crossnet_1way[[i]]) <- 
	    degree_1way_vars
}
names(tables_conc_1way) <- names(DTables_conc_1way) <- 
    names(plots_conc_1way) <- 
names(tables_crossnet_1way) <- names(DTables_crossnet_1way) <- 
    names(plots_crossnet_1way) <- 
	names(network_pairs)

``` 

### Mean degree overview
```{r nets-overview, results='asis'}
#------------------------------------------------------------
# Networks overview
# print
#------------------------------------------------------------
# kable(sumtable_nets_overview)
plots_nets_overview
knitr::knit_print(sumtable_nets_overview_DT)
```
```{r degree-nets-overview-2}
#plots_nets_overview
```

### One-way mean degree
```{r degree-1way-stats, results='asis'}
#------------------------------------------------------------
# 1-way stats: 
# print
#------------------------------------------------------------

for (var in degree_1way_vars){
   cat('\n')  
   cat("#### ", var, " {#degree-1way-", var, "}", "\n", sep="") 

    # Pring the plotly
    x <- plots_1way_mean[[var]]

    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x)$html)
    }

    # Print the data table
#   print(kable(tables_1way_mean[[var]]))
    cat(knitr::knit_print(DTables_1way_mean[[var]]))

   cat('\n') 
}
```

```{r degree-plotly-stuff-1way, echo=FALSE, messages=FALSE, warning=FALSE}
#------------------------------------------------------------
# Stuff necessary for plotly plots to print in a loop
# https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
# 
# KEY TO REALIZE: to have more than one loop of plotly graphs print at 
# different points in the same Rmd file, the "deps_1way" variable must
# have a unique name for each loop. So here, we have 1way, and later down,
# this code repeats again after the 2way loop with "deps_2way"
#------------------------------------------------------------
    # attach the Dependencies
    # since the do not get included with renderTags(...)$html
    deps_1way <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_1way_mean),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_1way,recursive=FALSE)
    )
```

### Two-way mean degree
```{r degree-2way-stats, results='asis'}
#------------------------------------------------------------
# 2-way stats: 
# print
#------------------------------------------------------------

for (var in degree_2way_vars_names){
   cat('\n')  
   cat("#### ", var, " {#degree-2way-", var, "}", "\n", sep="") 

    x <- plots_2way_mean[[var]]

    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x)$html)
    }

    # Print the data table
#    print(kable(tables_2way_mean[[var]]))
    cat(knitr::knit_print(DTables_2way_mean[[var]]))

   cat('\n') 
}
```

```{r degree-plotly-stuff-2way, echo=FALSE, messages=FALSE, warning=FALSE}
#------------------------------------------------------------
# Stuff necessary for plotly plots to print in a loop
# https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
# 
# KEY TO REALIZE: to have more than one loop of plotly graphs print at 
# different points in the same Rmd file, the "deps_2way" variable must
# have a unique name for each loop. So here, we have 2way, and later down,
# this code repeats again after the 2way loop with "deps_2way"
#------------------------------------------------------------
    # attach the Dependencies
    # since the do not get included with renderTags(...)$html
    deps_2way <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_2way_mean),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_2way,recursive=FALSE)
    )
```


```{r degree-crossnet-stats, results='asis'}
#------------------------------------------------------------
# Crossnet overview:
# print
#------------------------------------------------------------

for (netpair in names(network_pairs)){
    cat('\n')  
    cat("### Cross of ", netpair, " {#degree-overview-", netpair, "}", "\n", sep="") 
    cat("#### Overview\n")

    x <- plots_crossnet_overview[[netpair]]

    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x)$html)
    }

    x2 <- plots_crossnet_overview2[[netpair]]

    if(inherits(x2,"character")){
	cat(noquote(paste0(x2,collapse="\n")))
    } else {
	cat(renderTags(x2)$html)
    }
    # Print the data table
#    print(kable(tables_2way_mean[[var]]))
    cat(knitr::knit_print(DTables_crossnet_overview[[netpair]]))

    cat('\n')  
    #------------------------------------------------------------
    # Now print the 1-way stats for this network pair
    for (var in degree_1way_vars) {

       cat('\n')  
       cat("#### ", var, "{#degree-", netpair, "-xnet-", var, "}", "\n", sep="") 

	# Concurrency
	x2 <- plots_conc_1way[[netpair]][[var]]

	#  we know only character and htmlwidget in this case
	#   if more need to handle appropriately
	if(inherits(x2,"character")){
	    # noquote critical here
	    #  also turn off auto.asis very important
	    cat(noquote(paste0(x2,collapse="\n")))
	} else {
	    # print the html piece of the htmlwidgets
	    cat(renderTags(x2)$html)
	}

	# Print the data table
	cat(knitr::knit_print(DTables_conc_1way[[netpair]][[var]]))
	
	# Crossnet
	x3 <- plots_crossnet_1way[[netpair]][[var]]

	if(inherits(x3,"character")){
	    cat(noquote(paste0(x3,collapse="\n")))
	} else {
	    # print the html piece of the htmlwidgets
	    cat(renderTags(x3)$html)
	}

	# Print the data table
	cat(knitr::knit_print(DTables_crossnet_1way[[netpair]][[var]]))
	cat('\n') 
    }
   cat('\n') 

    #------------------------------------------------------------
    # Stuff necessary for plotly plots to print in a loop
    # I don't know if it needs to be within the loop across network pairs, 
    # but it is
    # https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
    # 
    # KEY TO REALIZE: to have more than one loop of plotly graphs print at 
    # different points in the same Rmd file, the "deps_2way" variable must
    # have a unique name for each loop. So here, we have 2way, and later down,
    # this code repeats again after the 2way loop with "deps_2way"
    #------------------------------------------------------------
    deps_conc_1way <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_conc_1way[[i]]),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_conc_1way,recursive=FALSE)
    )

    deps_crossnet_1way <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_crossnet_1way[[i]]),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_crossnet_1way,recursive=FALSE)
    )
}
```

```{r degree-plotly-stuff-conc-1way, echo=FALSE, messages=FALSE, warning=FALSE}
#------------------------------------------------------------
# Stuff necessary for plotly plots to print in a loop
# https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
# 
# KEY TO REALIZE: to have more than one loop of plotly graphs print at 
# different points in the same Rmd file, the "deps_2way" variable must
# have a unique name for each loop. So here, we have 2way, and later down,
# this code repeats again after the 2way loop with "deps_2way"
#------------------------------------------------------------
    # attach the Dependencies
    # since the do not get included with renderTags(...)$html
```
```{r degree-plotly-stuff-crossnet, echo=FALSE, messages=FALSE, warning=FALSE}
#------------------------------------------------------------
# Stuff necessary for plotly plots to print in a loop
# https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
# 
# KEY TO REALIZE: to have more than one loop of plotly graphs print at 
# different points in the same Rmd file, the "deps_2way" variable must
# have a unique name for each loop. So here, we have 2way, and later down,
# this code repeats again after the 2way loop with "deps_2way"
#------------------------------------------------------------
    # attach the Dependencies
    # since the do not get included with renderTags(...)$html
    deps_crossnet <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_crossnet_overview),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_crossnet,recursive=FALSE)
    )

    deps_crossnet2 <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_crossnet_overview2),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_crossnet2,recursive=FALSE)
    )
```



### Mixing

```{r mixing-setup, code=readLines('code/setup/packages-options.R')}
```

```{r, echo=FALSE, include=FALSE}
# https://github.com/rstudio/DT/issues/67
# You need this code to conduct the magic dependences attaching...
# Without it, the loops with DTs in them did NOT print
DT::datatable(matrix())
```

```{r mixing-mutate, echo=FALSE}
#--------------------------------------------------------------------------------
# Tibbles
# We will make a new survey object for every variable we mix
# Would like to document where we decided to use the ego weight, not ego weight/number of alters, as the relationship weight
#--------------------------------------------------------------------------------
egos4alters <- as_tibble(egos4alters)
alters <- transform(alters, network=factor(network, 
					   levels=network_order,
					   labels=network_order))
alters <- as_tibble(alters)
```

## One-way mixing

```{r mixing-tabs-plots-1way}
#------------------------------------------------------------
# 1-way stats: 
# compute tabs and generate plots
#------------------------------------------------------------

# Render plot_ly plots for use in a loop
# https://stackoverflow.com/questions/36234169/plotly-charts-in-a-for-loop
tables_1way <- list()
DTables_1way <- htmltools::tagList()
plots_1way <- htmltools::tagList()
for (i in 1:length(mixing_1way_vars)) {

    var <- mixing_1way_vars[i]
    var_quo <- rlang::sym(var)

    # Survey object for this variable
    mixdat <- tibble(network=alters$network,
		     weight=egos4alters$weight,
		     ego=as.character(egos4alters[[var]]),
		     alter=as.character(alters[[var]])) %>% 
	      unite(pair, c(ego, alter), remove=FALSE)

    svy <- mixdat %>% as_survey(ids=1, weights=weight)

    # Set factor levels for ego and alter 
    faclevels <- with(mixdat, sort(unique(c(ego, alter))))

    tables_1way[[i]] <- 
	# Abandoning this, which is marginal within networks. Instead,
	# focus on row-conditional
	#    prop_kvar(svy, pair, char_input=FALSE, binary=FALSE, network)  %>% 
	#    separate(pair, into=c('ego', 'alter'), sep='_', remove=FALSE)
	prop_kvar(svy, alter, char_input=FALSE, binary=FALSE, network, ego) %>% 
	# Use color to indicate homophily
	mutate(homophily=ifelse(ego==alter, 'Matched', 'Unmatched'),
	       alter=factor(alter, levels=faclevels, labels=faclevels),
	       ego=factor(ego, levels=rev(faclevels), labels=rev(faclevels)))

    # DT table
    DTables_1way[[i]] <- DT::datatable(tables_1way[[i]],
					   height="100%",
					   width="100%", rownames=FALSE)
    # Plotmix plot
    plot <- 
	ggplot(tables_1way[[i]],
		   aes(x=alter, y=ego, size=prop, color=homophily)) + 
		    geom_point() +
		    scale_size_continuous(range=c(0,20)) +
#			scale_fill_manual(values=c('springgreen4', 'gray68')) +
		    scale_color_manual(values=c('springgreen4', 'gray68')) +
		    theme_bw() + 
		    guides(size=FALSE) + 
		    labs(color='') + 
		    facet_grid(network~.) +
		    ggtitle('Ego/row conditional %')

    # I don't know why this works but plotly::style with hoverinfo='prop' does not
    plots_1way[[i]] <- as_widget(plotly::ggplotly(plot, tooltip='prop',
						  height=900, 
						  width=600))
}
names(tables_1way) <- names(DTables_1way) <- names(plots_1way) <- mixing_1way_vars
``` 


```{r mixing-1way-stats, results='asis'}
#------------------------------------------------------------
# 1-way stats: 
# print
#------------------------------------------------------------

for (var in mixing_1way_vars){
   cat('\n')  
   cat("### ", var, " {#mixing-1way-", var, "}", "\n", sep="") 

   # Now print the plot_ly
    x <- plots_1way[[var]]
    #  we know only character and htmlwidget in this case
    #   if more need to handle appropriately
    if(inherits(x,"character")){
	# noquote critical here
	#  also turn off auto.asis very important
	cat(noquote(paste0(x,collapse="\n")))
    } else {
	# print the html piece of the htmlwidgets
	cat(renderTags(x)$html)
    }

    cat(knitr::knit_print(DTables_1way[[var]]))

   cat('\n') 
}
```

```{r mixing-plotly-stuff-1way, echo=FALSE, messages=FALSE, warning=FALSE}
#------------------------------------------------------------
# Stuff necessary for plotly plots to print in a loop
# https://github.com/ropensci/plotly/issues/273#issuecomment-195611009
# 
# KEY TO REALIZE: to have more than one loop of plotly graphs print at 
# different points in the same Rmd file, the "deps_1way" variable must
# have a unique name for each loop. So here, we have 1way, and later down,
# this code repeats again after the 2way loop with "deps_2way"
#------------------------------------------------------------
    # attach the Dependencies
    # since the do not get included with renderTags(...)$html
    deps_1way <- lapply(
      Filter(function(x){inherits(x,"htmlwidget")},plots_1way),
      function(hw){
	renderTags(hw)$dependencies
      }
    )

    attachDependencies(
      tagList(),
      unlist(deps_1way,recursive=FALSE)
    )
```

